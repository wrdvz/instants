---
import { Client } from "@notionhq/client";
import "../styles/main.css";

/* ======================================================
   ENV
   - Cloudflare Pages (runtime)
   - Local dev (Vite / Astro)
====================================================== */

const runtimeEnv = Astro.locals?.runtime?.env ?? {};
const buildEnv = import.meta.env ?? {};

const NOTION_API_KEY =
  runtimeEnv.NOTION_API_KEY || buildEnv.NOTION_API_KEY;

const NOTION_DATABASE_ID =
  runtimeEnv.NOTION_DATABASE_ID || buildEnv.NOTION_DATABASE_ID;

const NOTION_PROFILE_DATABASE_ID =
  runtimeEnv.NOTION_PROFILE_DATABASE_ID || buildEnv.NOTION_PROFILE_DATABASE_ID;

if (!NOTION_API_KEY || !NOTION_DATABASE_ID || !NOTION_PROFILE_DATABASE_ID) {
  throw new Error("Missing environment variables");
}

/* ======================================================
   NOTION CLIENT
====================================================== */

const notion = new Client({ auth: NOTION_API_KEY });

/* ======================================================
   POSTS
====================================================== */

const postsRes = await notion.databases.query({
  database_id: NOTION_DATABASE_ID,
  filter: {
    property: "Published",
    checkbox: { equals: true }
  },
  sorts: [{ property: "Order", direction: "ascending" }]
});

const posts = postsRes.results
  .map((page) => {
    const imageProp = page.properties.Image;
    if (!imageProp || imageProp.type !== "files" || imageProp.files.length === 0) {
      return null;
    }

    return {
      title: page.properties.Title?.title?.[0]?.plain_text ?? "",
      images: imageProp.files.map(
        (f) => f.file?.url || f.external?.url
      ),
      caption: page.properties.Caption?.rich_text?.[0]?.plain_text ?? "",
      date: page.properties.Date?.date?.start ?? ""
    };
  })
  .filter(Boolean);

/* ======================================================
   PROFILE
====================================================== */

const profileRes = await notion.databases.query({
  database_id: NOTION_PROFILE_DATABASE_ID,
  filter: {
    property: "Published",
    checkbox: { equals: true }
  }
});

const profilePage = profileRes.results[0] ?? null;

const profile = profilePage
  ? {
      name: profilePage.properties.Username?.title?.[0]?.plain_text ?? "",
      bio: profilePage.properties.Bio?.rich_text ?? [],
      link: profilePage.properties.Website?.url ?? "",
      avatar:
        profilePage.properties.Avatar?.files?.[0]?.file?.url ||
        profilePage.properties.Avatar?.files?.[0]?.external?.url ||
        ""
    }
  : null;
---

<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Instants</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Inter font -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
    rel="stylesheet"
  />
</head>

<body>

<!-- ======================================================
     HOME HEADER (sticky, home only)
====================================================== -->
{profile && (
  <header class="profile">
    <img class="avatar" src={profile.avatar} alt={profile.name} />

    <div class="profile-meta">
      <h1>{profile.name}</h1>

      <div class="bio">
        {profile.bio.map((b) => <p>{b.plain_text}</p>)}
      </div>

      {profile.link && (
        <a href={profile.link} target="_blank" rel="noopener">
          {profile.link}
        </a>
      )}
    </div>
  </header>
)}

<!-- ======================================================
     FEED (grid)
====================================================== -->
<main class="feed">
  {posts.map((p) => (
    <img
      src={p.images[0]}
      alt={p.title}
      loading="eager"
      data-images={JSON.stringify(p.images)}
      data-caption={p.caption}
      data-date={p.date}
    />
  ))}
</main>

<!-- ======================================================
     POST VIEW (overlay)
====================================================== -->
<div id="lightbox" class="lightbox">

  <!-- Topbar (post only) -->
  <div class="post-topbar">
    <button id="backBtn" class="topbar-back" aria-label="Retour">‹</button>
    <div class="topbar-title">Post</div>
  </div>

  <!-- Scrollable post -->
  <div class="post">

    <!-- Mini profile -->
    <div class="post-header">
      <img class="post-avatar" src={profile?.avatar} />
      <div class="post-user">
        <div class="post-username">{profile?.name}</div>
        <div class="post-date"></div>
      </div>
    </div>

    <!-- Swipe zone -->
    <div class="lightbox-frame">
      <img class="img current" />
      <img class="img next" />
    </div>

    <!-- Caption -->
    <div class="post-meta">
      <p class="post-caption"></p>
    </div>

  </div>

  <!-- Nav (desktop mostly) -->
  <button class="nav prev">‹</button>
  <button class="nav next">›</button>
</div>

<!-- ======================================================
     CLIENT SCRIPT
====================================================== -->
<script>
/* ======================================================
   FEED FADE-IN
====================================================== */
document.querySelectorAll(".feed img").forEach((img) => {
  if (img.complete) img.classList.add("loaded");
  else img.addEventListener("load", () => img.classList.add("loaded"));
});

/* ======================================================
   DOM
====================================================== */
const lightbox = document.getElementById("lightbox");
const backBtn = document.getElementById("backBtn");

const frame = document.querySelector(".lightbox-frame");
const imgCurrent = frame.querySelector(".img.current");
const imgNext = frame.querySelector(".img.next");

const btnPrev = document.querySelector(".nav.prev");
const btnNext = document.querySelector(".nav.next");

const captionEl = document.querySelector(".post-caption");
const dateEl = document.querySelector(".post-date");

/* ======================================================
   STATE
====================================================== */
let images = [];
let index = 0;

let startX = 0;
let startY = 0;
let deltaX = 0;
let dragging = false;
let locked = false;
let startTime = 0;

const THRESHOLD = 0.2;

/* ======================================================
   OPEN / CLOSE POST
====================================================== */
function openPost(imgs, caption, date) {
  images = imgs;
  index = 0;

  imgCurrent.src = images[0];
  imgNext.style.opacity = "0";

  captionEl.textContent = caption || "";
  dateEl.textContent = date || "";

  lightbox.style.display = "block";
  document.body.style.overflow = "hidden";
}

function closePost() {
  lightbox.style.display = "none";
  document.body.style.overflow = "";
  images = [];
}

/* ======================================================
   SWIPE LOGIC
====================================================== */
frame.addEventListener("touchstart", (e) => {
  if (!images.length) return;

  const t = e.touches[0];
  startX = t.clientX;
  startY = t.clientY;
  startTime = Date.now();

  deltaX = 0;
  dragging = true;
  locked = false;

  imgCurrent.style.transition = "none";
  imgNext.style.transition = "none";
});

frame.addEventListener("touchmove", (e) => {
  if (!dragging) return;

  const t = e.touches[0];
  deltaX = t.clientX - startX;
  const deltaY = t.clientY - startY;

  if (!locked) {
    if (Math.abs(deltaX) > Math.abs(deltaY)) locked = true;
    else return;
  }

  e.preventDefault();

  const width = frame.offsetWidth;
  const direction = deltaX < 0 ? 1 : -1;
  const target = index + direction;

  if (!images[target]) {
    imgCurrent.style.transform = `translateX(${deltaX * 0.35}px)`;
    return;
  }

  const dampedX = deltaX * 0.95;

  imgNext.src = images[target];
  imgNext.style.opacity = "1";

  imgCurrent.style.transform = `translateX(${dampedX}px)`;
  imgNext.style.transform =
    `translateX(${dampedX + (direction > 0 ? width : -width)}px)`;
});

frame.addEventListener("touchend", () => {
  if (!dragging) return;
  dragging = false;

  const width = frame.offsetWidth;
  const elapsed = Date.now() - startTime;
  const velocity = Math.abs(deltaX) / elapsed;
  const distanceRatio = Math.abs(deltaX) / width;

  const direction = deltaX < 0 ? 1 : -1;
  const target = index + direction;

  imgCurrent.style.transition =
    "transform 0.35s cubic-bezier(0.22, 1, 0.36, 1)";
  imgNext.style.transition =
    "transform 0.35s cubic-bezier(0.22, 1, 0.36, 1)";

  const shouldSwipe =
    images[target] &&
    (distanceRatio > THRESHOLD || velocity > 0.6);

  if (shouldSwipe) {
    imgCurrent.style.transform =
      `translateX(${direction > 0 ? -width : width}px)`;
    imgNext.style.transform = "translateX(0)";

    setTimeout(() => {
      index = target;
      imgCurrent.src = imgNext.src;
      resetImages();
    }, 350);
  } else {
    imgCurrent.style.transform = "translateX(0)";
    imgNext.style.opacity = "0";
    setTimeout(resetImages, 350);
  }
});

function resetImages() {
  imgCurrent.style.transition = "";
  imgNext.style.transition = "";
  imgCurrent.style.transform = "";
  imgNext.style.transform = "";
  imgNext.style.opacity = "0";
}

/* ======================================================
   EVENTS
====================================================== */
document.querySelectorAll(".feed img").forEach((img) => {
  img.addEventListener("click", () => {
    openPost(
      JSON.parse(img.dataset.images),
      img.dataset.caption,
      img.dataset.date
    );
  });
});

backBtn.onclick = closePost;

btnPrev.onclick = () => {
  if (index > 0) {
    deltaX = 1;
    frame.dispatchEvent(new Event("touchend"));
  }
};

btnNext.onclick = () => {
  if (index < images.length - 1) {
    deltaX = -1;
    frame.dispatchEvent(new Event("touchend"));
  }
};
</script>

</body>
</html>