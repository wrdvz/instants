---
/* ======================================================
   SECTION A — CONFIG & IMPORTS (serveur)
   - Cette partie tourne côté serveur (Astro)
   - Elle ne sera JAMAIS exécutée dans le navigateur
====================================================== */

import { Client } from "@notionhq/client";
import "../styles/main.css";



/* ======================================================
   SECTION B — VARIABLES D’ENVIRONNEMENT
   - Permet de fonctionner en local ET sur Cloudflare
====================================================== */

const runtimeEnv = Astro.locals?.runtime?.env ?? {};
const buildEnv = import.meta.env ?? {};

const NOTION_API_KEY =
  runtimeEnv.NOTION_API_KEY || buildEnv.NOTION_API_KEY;
const NOTION_DATABASE_ID =
  runtimeEnv.NOTION_DATABASE_ID || buildEnv.NOTION_DATABASE_ID;
const NOTION_PROFILE_DATABASE_ID =
  runtimeEnv.NOTION_PROFILE_DATABASE_ID || buildEnv.NOTION_PROFILE_DATABASE_ID;

if (!NOTION_API_KEY || !NOTION_DATABASE_ID || !NOTION_PROFILE_DATABASE_ID) {
  throw new Error("Missing environment variables");
}

/* ======================================================
   SECTION C — CLIENT NOTION
====================================================== */

const notion = new Client({ auth: NOTION_API_KEY });

/* ======================================================
   SECTION D — RÉCUPÉRATION DES POSTS
   - On transforme la réponse Notion en données simples
   - Le HTML ne connaîtra JAMAIS Notion directement
====================================================== */

const postsRes = await notion.databases.query({
  database_id: NOTION_DATABASE_ID,
  filter: { property: "Published", checkbox: { equals: true } },
  sorts: [{ property: "Order", direction: "ascending" }]
});

const posts = postsRes.results
  .map((page) => {
    const files = page.properties.Image?.files;
    if (!files?.length) return null;

    return {
      images: files.map(f => f.file?.url || f.external?.url),
      caption: page.properties.Caption?.rich_text?.[0]?.plain_text ?? "",
      date: page.properties.Date?.date?.start ?? ""
    };
  })
  .filter(Boolean);

  

/* ======================================================
   SECTION E — RÉCUPÉRATION DU PROFIL
====================================================== */

const profileRes = await notion.databases.query({
  database_id: NOTION_PROFILE_DATABASE_ID,
  filter: { property: "Published", checkbox: { equals: true } }
});

const profilePage = profileRes.results[0];
const profile = {
  name: profilePage.properties.Username.title[0].plain_text,
  bio: profilePage.properties.Bio.rich_text,
  avatar:
    profilePage.properties.Avatar.files[0].file?.url ||
    profilePage.properties.Avatar.files[0].external?.url
};
---

<!DOCTYPE html>
<html lang="fr">
<head>
  <!-- ======================================================
       SECTION F — HEAD HTML
       - Fonts
       - Meta viewport (important pour iOS)
  ====================================================== -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Instants</title>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
    rel="stylesheet"
  />
</head>

<body>

<!-- ======================================================
     SECTION G — HEADER HOME (profil)
====================================================== -->
<header class="profile">
  <img class="avatar" src={profile.avatar} alt={profile.name} />
  <div class="profile-text">
    <h1>{profile.name}</h1>
    {profile.bio.map(b => <p>{b.plain_text}</p>)}
  </div>
</header>

<!-- ======================================================
     SECTION H — FEED (grille d’images)
     - Chaque image contient ses données en data-*
====================================================== -->
<main class="feed">
  {posts.map(p => (
    <img
      src={p.images[0]}
      alt=""
      data-images={JSON.stringify(p.images)}
      data-caption={p.caption}
      data-date={p.date}
    />
  ))}
</main>

<!-- ======================================================
  SECTION I — OVERLAY POST (lightbox)
====================================================== -->
<div id="lightbox" class="lightbox">

  <!-- I.1 — Topbar -->
  <div class="post-topbar">
    
<div id="backBtn" class="topbar-back" role="button" aria-label="Retour">
   <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="size-4">
  <path fill-rule="evenodd" d="M9.78 4.22a.75.75 0 0 1 0 1.06L7.06 8l2.72 2.72a.75.75 0 1 1-1.06 1.06L5.47 8.53a.75.75 0 0 1 0-1.06l3.25-3.25a.75.75 0 0 1 1.06 0Z" clip-rule="evenodd" />
</svg>
</div>
    <div class="topbar-title">Post</div>
  </div>

  <!-- I.2 — Contenu scrollable -->
  <div class="post">

    <!-- I.2.a — Header post -->
    <div class="post-header">
      <img class="post-avatar" src={profile?.avatar} />
      <div class="post-user">
        <div class="post-username">{profile?.name}</div>
        <div class="post-date"></div>
      </div>
    </div>

    <!-- I.2.b — Image + carousel -->
    <div class="image-wrapper">
      <img class="img current" />
      <img class="img next" />

      <button class="nav prev icon-btn">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="size-4">
  <path fill-rule="evenodd" d="M9.78 4.22a.75.75 0 0 1 0 1.06L7.06 8l2.72 2.72a.75.75 0 1 1-1.06 1.06L5.47 8.53a.75.75 0 0 1 0-1.06l3.25-3.25a.75.75 0 0 1 1.06 0Z" clip-rule="evenodd" />
</svg>

      </button>
      <button class="nav next icon-btn">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="size-4">
  <path fill-rule="evenodd" d="M6.22 4.22a.75.75 0 0 1 1.06 0l3.25 3.25a.75.75 0 0 1 0 1.06l-3.25 3.25a.75.75 0 0 1-1.06-1.06L8.94 8 6.22 5.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd" />
</svg>
      </button>
    </div>

    <!-- I.2.c — Actions -->
    <div class="actions">
      <button class="icon-btn like-btn">
        <svg 
  xmlns="http://www.w3.org/2000/svg"
  viewBox="0 0 24 24"
  class="icon-outline"
  stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12Z" />
</svg>
      </button>
    </div>

    <!-- I.2.d — Caption -->
    <div class="post-meta">
      <p class="post-caption"></p>
    </div>

   

<!-- ======================================================
     SECTION J — SCRIPT CLIENT (interactions)
====================================================== -->
<script>
(() => {

  document.addEventListener("DOMContentLoaded", () => {

    /* =========================
       DOM
    ========================= */
    const lightbox = document.getElementById("lightbox");
    const frame = document.querySelector(".image-wrapper");
    const imgCurrent = document.querySelector(".img.current");
    const imgNext = document.querySelector(".img.next");
    const captionEl = document.querySelector(".post-caption");
    const dateEl = document.querySelector(".post-date");
    const backBtn = document.getElementById("backBtn");
    const likeBtn = document.querySelector(".like-btn");
    const prevBtn = document.querySelector(".nav.prev");
    const nextBtn = document.querySelector(".nav.next");

    if (!lightbox || !frame || !imgCurrent) return;

    /* =========================
       STATE
    ========================= */
    let images = [];
    let index = 0;
    let isAnimating = false;

    /* =========================
       HELPERS
    ========================= */
    function resetImages() {
  imgCurrent.style.opacity = "1";       
  imgNext.style.transition = "";
  imgNext.style.transform = "";
  imgNext.style.opacity = "0";
  imgNext.classList.remove("loading");
}

    function goToImage(direction) {
  if (isAnimating) return;

  const target = index + direction;
  if (!images[target]) return;

  isAnimating = true;
  const width = frame.offsetWidth;

  imgNext.src = images[target];
  imgNext.style.opacity = "1";

  // 1️⃣ attendre que l’image soit vraiment prête
  imgNext.decode().then(() => {

    imgCurrent.style.transition =
      "transform 0.35s cubic-bezier(0.22,1,0.36,1)";
    imgNext.style.transition =
      "transform 0.35s cubic-bezier(0.22,1,0.36,1)";

    imgCurrent.style.transform =
      `translateX(${direction > 0 ? -width : width}px)`;
    imgNext.style.transform = "translateX(0)";

    // 2️⃣ swap uniquement après animation
    setTimeout(() => {
      imgCurrent.src = imgNext.src;
      imgCurrent.style.transform = "translateX(0)";
      imgCurrent.style.transition = "";

      resetImages();
      index = target;
      isAnimating = false;
    }, 350);

  });
}

  function rubberBand() {
  imgCurrent.style.transition =
    "transform 0.35s cubic-bezier(0.22,1,0.36,1)";
  imgCurrent.style.transform = "translateX(0)";
}

let gesture = null; // "horizontal" | "vertical" | null
const LOCK_THRESHOLD = 8;

    /* =========================
       OPEN POST
    ========================= */
    document.querySelectorAll(".feed img").forEach(img => {
      img.addEventListener("click", () => {
        images = JSON.parse(img.dataset.images);
        index = 0;

        imgCurrent.src = images[0];
        captionEl.textContent = img.dataset.caption || "";
        if (dateEl) dateEl.textContent = img.dataset.date || "";

        lightbox.style.display = "block";
        document.body.style.overflow = "hidden";
      });
    });

    /* =========================
       CLOSE
    ========================= */
    backBtn.addEventListener("click", () => {
      lightbox.style.display = "none";
      document.body.style.overflow = "";
    });

    /* =========================
       BUTTONS
    ========================= */
    prevBtn.addEventListener("click", e => {
      e.stopPropagation();
      goToImage(-1);
    });

    nextBtn.addEventListener("click", e => {
      e.stopPropagation();
      goToImage(1);
    });

    /* =========================
       LIKE
    ========================= */
    likeBtn?.addEventListener("click", () => {
      likeBtn.classList.toggle("liked");
    });

    /* =========================
       SWIPE iOS
    ========================= */
    let startX = 0;
let startY = 0;
let deltaX = 0;
let deltaY = 0; 
    let dragging = false;

    frame.addEventListener("touchstart", e => {
  startX = e.touches[0].clientX;
  startY = e.touches[0].clientY;
  deltaX = 0;
  deltaY = 0;
  dragging = true;
  gesture = null;

  imgCurrent.style.transition = "none";
  imgNext.style.transition = "none";
}, { passive: true });


    frame.addEventListener("touchmove", e => {
  if (!dragging || isAnimating) return;

  deltaX = e.touches[0].clientX - startX;
  deltaY = e.touches[0].clientY - startY;

  // tant qu’on n’a pas décidé, on observe
  if (!gesture) {
    if (
      Math.abs(deltaX) < LOCK_THRESHOLD &&
      Math.abs(deltaY) < LOCK_THRESHOLD
    ) {
      return;
    }

    gesture =
      Math.abs(deltaX) > Math.abs(deltaY)
        ? "horizontal"
        : "vertical";
  }

  // GESTE VERTICAL → on laisse le scroll vivre sa vie
  if (gesture === "vertical") {
    return;
  }

  // GESTE HORIZONTAL → on bloque le scroll
  e.preventDefault();

  const width = frame.offsetWidth;
  const direction = deltaX < 0 ? 1 : -1;
  const target = index + direction;

  let x = deltaX;
  const limit = 30;

  if (!images[target] && Math.abs(deltaX) > limit) {
    const overflow = Math.abs(deltaX) - limit;
    x =
      Math.sign(deltaX) *
      (limit + Math.sqrt(overflow) * 6);
  }

  imgCurrent.style.transform = `translateX(${x}px)`;

  if (images[target]) {
    imgNext.src = images[target];
    imgNext.style.opacity = "1";
    imgNext.style.transform =
      `translateX(${x + (direction > 0 ? width : -width)}px)`;
  }
}, { passive: false });

    frame.addEventListener("touchend", () => {
  if (!dragging) return;

  dragging = false;

  if (gesture !== "horizontal") return;

  const width = frame.offsetWidth;
  const progress = Math.abs(deltaX) / width;
  const direction = deltaX < 0 ? 1 : -1;
  const target = index + direction;

  if (progress > 0.2 && images[target]) {
    goToImage(direction);
  } else {
    rubberBand();
  
  }
});

  });

})();
</script>


</body>
</html>